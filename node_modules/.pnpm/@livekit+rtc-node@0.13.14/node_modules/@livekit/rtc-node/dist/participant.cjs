"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var participant_exports = {};
__export(participant_exports, {
  LocalParticipant: () => LocalParticipant,
  Participant: () => Participant,
  RemoteParticipant: () => RemoteParticipant
});
module.exports = __toCommonJS(participant_exports);
var import_mutex = require("@livekit/mutex");
var import_promises = require("node:fs/promises");
var import_data_streams = require("./data_streams/index.cjs");
var import_ffi_client = require("./ffi_client.cjs");
var import_log = require("./log.cjs");
var import_participant_pb = require("./proto/participant_pb.cjs");
var import_room_pb = require("./proto/room_pb.cjs");
var import_room_pb2 = require("./proto/room_pb.cjs");
var import_room_pb3 = require("./proto/room_pb.cjs");
var import_rpc_pb = require("./proto/rpc_pb.cjs");
var import_rpc = require("./rpc.cjs");
var import_track_publication = require("./track_publication.cjs");
var import_utils = require("./utils.cjs");
const STREAM_CHUNK_SIZE = 15e3;
class Participant {
  constructor(owned_info) {
    this.trackPublications = /* @__PURE__ */ new Map();
    this.info = owned_info.info;
    this.ffi_handle = new import_ffi_client.FfiHandle(owned_info.handle.id);
  }
  get sid() {
    return this.info.sid;
  }
  get name() {
    return this.info.name;
  }
  get identity() {
    return this.info.identity ?? "";
  }
  get metadata() {
    return this.info.metadata ?? "";
  }
  get attributes() {
    return this.info.attributes ?? {};
  }
  get kind() {
    return this.info.kind ?? import_participant_pb.ParticipantKind.STANDARD;
  }
  get disconnectReason() {
    if (this.info.disconnectReason === import_participant_pb.DisconnectReason.UNKNOWN_REASON) {
      return void 0;
    }
    return this.info.disconnectReason;
  }
}
class LocalParticipant extends Participant {
  constructor() {
    super(...arguments);
    this.rpcHandlers = /* @__PURE__ */ new Map();
    this.trackPublications = /* @__PURE__ */ new Map();
  }
  async publishData(data, options) {
    const req = new import_room_pb3.PublishDataRequest({
      localParticipantHandle: this.ffi_handle.handle,
      dataPtr: import_ffi_client.FfiClient.instance.retrievePtr(data),
      dataLen: BigInt(data.byteLength),
      reliable: options.reliable,
      topic: options.topic,
      destinationIdentities: options.destination_identities
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "publishData", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "publishData" && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
  }
  async publishDtmf(code, digit) {
    const req = new import_room_pb3.PublishSipDtmfRequest({
      localParticipantHandle: this.ffi_handle.handle,
      code,
      digit
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "publishSipDtmf", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "publishSipDtmf" && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
  }
  async publishTranscription(transcription) {
    const req = new import_room_pb3.PublishTranscriptionRequest({
      localParticipantHandle: this.ffi_handle.handle,
      participantIdentity: transcription.participantIdentity,
      segments: transcription.segments.map(
        (s) => new import_room_pb3.TranscriptionSegment({
          id: s.id,
          text: s.text,
          startTime: s.startTime,
          endTime: s.endTime,
          final: s.final,
          language: s.language
        })
      ),
      trackId: transcription.trackSid
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "publishTranscription", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "publishTranscription" && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
  }
  async updateMetadata(metadata) {
    const req = new import_room_pb3.SetLocalMetadataRequest({
      localParticipantHandle: this.ffi_handle.handle,
      metadata
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "setLocalMetadata", value: req }
    });
    await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "setLocalMetadata" && ev.message.value.asyncId == res.asyncId;
    });
  }
  /**
   * Returns a `StreamWriter` instance that allows to write individual chunks of text to a stream.
   * Well suited for TTS and/or streaming LLM output. If you want to simply send a text then use sendText() instead
   */
  async streamText(options) {
    const senderIdentity = (options == null ? void 0 : options.senderIdentity) ?? this.identity;
    const streamId = (options == null ? void 0 : options.streamId) ?? crypto.randomUUID();
    const destinationIdentities = options == null ? void 0 : options.destinationIdentities;
    const info = {
      streamId,
      mimeType: "text/plain",
      topic: (options == null ? void 0 : options.topic) ?? "",
      timestamp: Date.now()
    };
    const headerReq = new import_room_pb.SendStreamHeaderRequest({
      senderIdentity,
      destinationIdentities,
      localParticipantHandle: this.ffi_handle.handle,
      header: new import_room_pb.DataStream_Header({
        streamId,
        mimeType: info.mimeType,
        topic: info.topic,
        timestamp: (0, import_utils.numberToBigInt)(info.timestamp),
        attributes: options == null ? void 0 : options.attributes,
        contentHeader: {
          case: "textHeader",
          value: new import_room_pb.DataStream_TextHeader({
            operationType: import_room_pb.DataStream_OperationType.CREATE,
            version: 0,
            replyToStreamId: "",
            generated: false
          })
        }
      })
    });
    await this.sendStreamHeader(headerReq);
    let nextChunkId = 0;
    const localHandle = this.ffi_handle.handle;
    const sendTrailer = this.sendStreamTrailer;
    const sendChunk = this.sendStreamChunk;
    const writableStream = new WritableStream({
      // Implement the sink
      async write(text) {
        for (const textByteChunk of (0, import_utils.splitUtf8)(text, STREAM_CHUNK_SIZE)) {
          const chunkRequest = new import_room_pb.SendStreamChunkRequest({
            senderIdentity,
            localParticipantHandle: localHandle,
            destinationIdentities,
            chunk: new import_room_pb.DataStream_Chunk({
              content: textByteChunk,
              streamId,
              chunkIndex: (0, import_utils.numberToBigInt)(nextChunkId)
            })
          });
          await sendChunk(chunkRequest);
          nextChunkId += 1;
        }
      },
      async close() {
        const trailerReq = new import_room_pb.SendStreamTrailerRequest({
          senderIdentity,
          localParticipantHandle: localHandle,
          destinationIdentities,
          trailer: new import_room_pb.DataStream_Trailer({
            streamId,
            reason: ""
          })
        });
        await sendTrailer(trailerReq);
      },
      abort(err) {
        import_log.log.error("Sink error:", err);
      }
    });
    const writer = new import_data_streams.TextStreamWriter(writableStream, info);
    return writer;
  }
  async sendText(text, options) {
    const writer = await this.streamText(options);
    await writer.write(text);
    await writer.close();
    return writer.info;
  }
  async streamBytes(options) {
    const senderIdentity = this.identity;
    const streamId = (options == null ? void 0 : options.streamId) ?? crypto.randomUUID();
    const destinationIdentities = options == null ? void 0 : options.destinationIdentities;
    const info = {
      streamId,
      mimeType: (options == null ? void 0 : options.mimeType) ?? "application/octet-stream",
      topic: (options == null ? void 0 : options.topic) ?? "",
      timestamp: Date.now(),
      attributes: options == null ? void 0 : options.attributes,
      totalSize: options == null ? void 0 : options.totalSize,
      name: (options == null ? void 0 : options.name) ?? "unknown"
    };
    const headerReq = new import_room_pb.SendStreamHeaderRequest({
      senderIdentity,
      destinationIdentities,
      localParticipantHandle: this.ffi_handle.handle,
      header: new import_room_pb.DataStream_Header({
        streamId,
        mimeType: info.mimeType,
        topic: info.topic,
        timestamp: (0, import_utils.numberToBigInt)(info.timestamp),
        attributes: info.attributes,
        totalLength: (0, import_utils.numberToBigInt)(info.totalSize),
        contentHeader: {
          case: "byteHeader",
          value: new import_room_pb.DataStream_ByteHeader({
            name: info.name
          })
        }
      })
    });
    await this.sendStreamHeader(headerReq);
    let chunkId = 0;
    const localHandle = this.ffi_handle.handle;
    const sendTrailer = this.sendStreamTrailer;
    const sendChunk = this.sendStreamChunk;
    const writeMutex = new import_mutex.Mutex();
    const writableStream = new WritableStream({
      async write(chunk) {
        const unlock = await writeMutex.lock();
        let byteOffset = 0;
        try {
          while (byteOffset < chunk.byteLength) {
            const subChunk = chunk.slice(byteOffset, byteOffset + STREAM_CHUNK_SIZE);
            const chunkRequest = new import_room_pb.SendStreamChunkRequest({
              senderIdentity,
              localParticipantHandle: localHandle,
              destinationIdentities,
              chunk: new import_room_pb.DataStream_Chunk({
                content: subChunk,
                streamId,
                chunkIndex: (0, import_utils.numberToBigInt)(chunkId)
              })
            });
            await sendChunk(chunkRequest);
            chunkId += 1;
            byteOffset += subChunk.byteLength;
          }
        } finally {
          unlock();
        }
      },
      async close() {
        const trailerReq = new import_room_pb.SendStreamTrailerRequest({
          senderIdentity,
          localParticipantHandle: localHandle,
          destinationIdentities,
          trailer: new import_room_pb.DataStream_Trailer({
            streamId,
            reason: ""
          })
        });
        await sendTrailer(trailerReq);
      },
      abort(err) {
        import_log.log.error("Sink error:", err);
      }
    });
    const byteWriter = new import_data_streams.ByteStreamWriter(writableStream, info);
    return byteWriter;
  }
  /** Sends a file provided as PathLike to specified recipients */
  async sendFile(path, options) {
    const fileStats = await (0, import_promises.stat)(path);
    const file = await (0, import_promises.open)(path);
    try {
      const stream = file.readableWebStream({ type: "bytes" });
      const streamId = crypto.randomUUID();
      const destinationIdentities = options == null ? void 0 : options.destinationIdentities;
      const writer = await this.streamBytes({
        streamId,
        name: options == null ? void 0 : options.name,
        totalSize: fileStats.size,
        destinationIdentities,
        topic: options == null ? void 0 : options.topic,
        mimeType: options == null ? void 0 : options.mimeType,
        attributes: options == null ? void 0 : options.attributes
      });
      for await (const chunk of stream) {
        await writer.write(chunk);
      }
      await writer.close();
    } finally {
      await file.close();
    }
  }
  async sendStreamHeader(req) {
    const type = "sendStreamHeader";
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: type, value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == type && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
  }
  async sendStreamChunk(req) {
    const type = "sendStreamChunk";
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: type, value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == type && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
  }
  async sendStreamTrailer(req) {
    const type = "sendStreamTrailer";
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: type, value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == type && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
  }
  /**
   * Sends a chat message to participants in the room
   *
   * @param text - The text content of the chat message.
   * @param destinationIdentities - An optional array of recipient identities to whom the message will be sent. If omitted, the message is broadcast to all participants.
   * @param senderIdentity - An optional identity of the sender. If omitted, the default sender identity is used.
   *
   */
  async sendChatMessage(text, destinationIdentities, senderIdentity) {
    const req = new import_room_pb3.SendChatMessageRequest({
      localParticipantHandle: this.ffi_handle.handle,
      message: text,
      destinationIdentities,
      senderIdentity
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "sendChatMessage", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "chatMessage" && ev.message.value.asyncId == res.asyncId;
    });
    switch (cb.message.case) {
      case "chatMessage":
        const { id, timestamp, editTimestamp, message } = cb.message.value;
        return {
          id,
          timestamp: Number(timestamp),
          editTimestamp: Number(editTimestamp),
          message
        };
      case "error":
      default:
        throw new Error(cb.message.value);
    }
  }
  /**
   * @experimental
   */
  async editChatMessage(editText, originalMessage, destinationIdentities, senderIdentity) {
    const req = new import_room_pb3.EditChatMessageRequest({
      localParticipantHandle: this.ffi_handle.handle,
      editText,
      originalMessage: new import_room_pb2.ChatMessage({
        ...originalMessage,
        timestamp: BigInt(originalMessage.timestamp),
        editTimestamp: originalMessage.editTimestamp ? BigInt(originalMessage.editTimestamp) : void 0
      }),
      destinationIdentities,
      senderIdentity
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "editChatMessage", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "chatMessage" && ev.message.value.asyncId == res.asyncId;
    });
    switch (cb.message.case) {
      case "chatMessage":
        const { id, timestamp, editTimestamp, message } = cb.message.value;
        return {
          id,
          timestamp: Number(timestamp),
          editTimestamp: Number(editTimestamp),
          message
        };
      case "error":
      default:
        throw new Error(cb.message.value);
    }
  }
  async updateName(name) {
    const req = new import_room_pb3.SetLocalNameRequest({
      localParticipantHandle: this.ffi_handle.handle,
      name
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "setLocalName", value: req }
    });
    await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "setLocalName" && ev.message.value.asyncId == res.asyncId;
    });
  }
  async setAttributes(attributes) {
    const req = new import_room_pb3.SetLocalAttributesRequest({
      localParticipantHandle: this.ffi_handle.handle,
      attributes: Object.entries(attributes).map(([key, value]) => ({ key, value }))
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "setLocalAttributes", value: req }
    });
    await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "setLocalAttributes" && ev.message.value.asyncId == res.asyncId;
    });
  }
  async publishTrack(track, options) {
    const req = new import_room_pb3.PublishTrackRequest({
      localParticipantHandle: this.ffi_handle.handle,
      trackHandle: track.ffi_handle.handle,
      options
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "publishTrack", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "publishTrack" && ev.message.value.asyncId == res.asyncId;
    });
    switch (cb.message.case) {
      case "publication":
        const track_publication = new import_track_publication.LocalTrackPublication(cb.message.value);
        track_publication.track = track;
        this.trackPublications.set(track_publication.sid, track_publication);
        return track_publication;
      case "error":
      default:
        throw new Error(cb.message.value);
    }
  }
  async unpublishTrack(trackSid, stopOnUnpublish) {
    const req = new import_room_pb3.UnpublishTrackRequest({
      localParticipantHandle: this.ffi_handle.handle,
      trackSid,
      stopOnUnpublish: stopOnUnpublish ?? true
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "unpublishTrack", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "unpublishTrack" && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
    const pub = this.trackPublications.get(trackSid);
    if (pub) {
      pub.track = void 0;
    }
    this.trackPublications.delete(trackSid);
  }
  /**
   * Initiate an RPC call to a remote participant.
   * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}
   * @returns A promise that resolves with the response payload or rejects with an error.
   * @throws Error on failure. Details in `message`.
   */
  async performRpc({
    destinationIdentity,
    method,
    payload,
    responseTimeout
  }) {
    const req = new import_rpc_pb.PerformRpcRequest({
      localParticipantHandle: this.ffi_handle.handle,
      destinationIdentity,
      method,
      payload,
      responseTimeoutMs: responseTimeout
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "performRpc", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case === "performRpc" && ev.message.value.asyncId === res.asyncId;
    });
    if (cb.error) {
      throw import_rpc.RpcError.fromProto(cb.error);
    }
    return cb.payload;
  }
  /**
   * Establishes the participant as a receiver for calls of the specified RPC method.
   * Will overwrite any existing callback for the same method.
   *
   * @param method - The name of the indicated RPC method
   * @param handler - Will be invoked when an RPC request for this method is received
   * @returns A promise that resolves when the method is successfully registered
   *
   * @example
   * ```typescript
   * room.localParticipant?.registerRpcMethod(
   *   'greet',
   *   async (data: RpcInvocationData) => {
   *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);
   *     return `Hello, ${data.callerIdentity}!`;
   *   }
   * );
   * ```
   *
   * See {@link RpcInvocationData} for more details on invocation params.
   *
   * The handler should return a Promise that resolves to a string.
   * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.
   *
   * You may throw errors of type `RpcError` with a string `message` in the handler,
   * and they will be received on the caller's side with the message intact.
   * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` ("Application Error").
   */
  registerRpcMethod(method, handler) {
    this.rpcHandlers.set(method, handler);
    const req = new import_rpc_pb.RegisterRpcMethodRequest({
      localParticipantHandle: this.ffi_handle.handle,
      method
    });
    import_ffi_client.FfiClient.instance.request({
      message: { case: "registerRpcMethod", value: req }
    });
  }
  /**
   * Unregisters a previously registered RPC method.
   *
   * @param method - The name of the RPC method to unregister
   */
  unregisterRpcMethod(method) {
    this.rpcHandlers.delete(method);
    const req = new import_rpc_pb.UnregisterRpcMethodRequest({
      localParticipantHandle: this.ffi_handle.handle,
      method
    });
    import_ffi_client.FfiClient.instance.request({
      message: { case: "unregisterRpcMethod", value: req }
    });
  }
  /** @internal */
  async handleRpcMethodInvocation(invocationId, method, requestId, callerIdentity, payload, responseTimeout) {
    let responseError = null;
    let responsePayload = null;
    const handler = this.rpcHandlers.get(method);
    if (!handler) {
      responseError = import_rpc.RpcError.builtIn("UNSUPPORTED_METHOD");
    } else {
      try {
        responsePayload = await handler({ requestId, callerIdentity, payload, responseTimeout });
      } catch (error) {
        if (error instanceof import_rpc.RpcError) {
          responseError = error;
        } else {
          console.warn(
            `Uncaught error returned by RPC handler for ${method}. Returning APPLICATION_ERROR instead.`,
            error
          );
          responseError = import_rpc.RpcError.builtIn("APPLICATION_ERROR");
        }
      }
    }
    const req = new import_rpc_pb.RpcMethodInvocationResponseRequest({
      localParticipantHandle: this.ffi_handle.handle,
      invocationId,
      error: responseError ? responseError.toProto() : void 0,
      payload: responsePayload ?? void 0
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "rpcMethodInvocationResponse", value: req }
    });
    if (res.error) {
      console.warn(`error sending rpc method invocation response: ${res.error}`);
    }
  }
}
class RemoteParticipant extends Participant {
  constructor(owned_info) {
    super(owned_info);
    this.trackPublications = /* @__PURE__ */ new Map();
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  LocalParticipant,
  Participant,
  RemoteParticipant
});
//# sourceMappingURL=participant.cjs.map